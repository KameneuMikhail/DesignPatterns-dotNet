using System;

namespace DesignPatterns.Behavioral
{
    /// <summary>
    /*
     Представьте, что вы делаете систему приёма онлайн-заказов.
    Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы.
    Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно.
    Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль.
    Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла.

Проблема, которую решает Цепочка обязанностей
Запрос проходит ряд проверок перед доступом в систему заказов.

Как и многие другие поведенческие паттерны, Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты.
    В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения.
    Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

А теперь по-настоящему важный этап. Паттерн предлагает связать объекты обработчиков в одну цепь.
    Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, вы можете быть уверены, что все объекты в цепи смогут его обработать.
    При этом длина цепочки не имеет никакого значения.

И последний штрих. Обработчик не обязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.

В примере с фильтрацией доступа обработчики прерывают дальнейшие проверки, если текущая проверка не прошла.
    Ведь нет смысла тратить попусту ресурсы, если и так понятно, что с запросом что-то не так.

Но есть и другой подход, при котором обработчики прерывают цепь только когда они могут обработать запрос.
    В этом случае запрос движется по цепи, пока не найдётся обработчик, который может его обработать.
    Очень часто такой подход используется для передачи событий, создаваемых классами графического интерфейса в результате взаимодействия с пользователем.

Очень важно, чтобы все объекты цепочки имели общий интерфейс.
    Обычно каждому конкретному обработчику достаточно знать только то, что следующий объект в цепи имеет метод выполнить.
    Благодаря этому связи между объектами цепочки будут более гибкими. Кроме того, вы сможете формировать цепочки на лету из разнообразных объектов, не привязываясь к конкретным классам.
     */
    /// </summary>
    public class ChainOfResponsibility
    {
        #region Chain Of Responsibility

        public interface IOrderHandler
        {
            IOrderHandler SetNextHandler(IOrderHandler handler);
            string Find();
        }

        public abstract class OrderHandlerBase : IOrderHandler
        {
            protected IOrderHandler handler;
            public abstract string Find();

            public IOrderHandler SetNextHandler(IOrderHandler handler)
            {
                this.handler = handler;
                return handler;
            }
        }

        public class CachedOrderHandler : OrderHandlerBase
        {
            public override string Find()
            {
                return FindElement();
            }

            private string FindElement()
            {
                if (new Random().Next(0, 10) == 3)
                    return "Cached element returned";

                if (this.handler != null)
                    return this.handler.Find();

                return null;
            }
        }

        public class HttpOrderHandler : OrderHandlerBase
        {
            public override string Find()
            {
                return FindElement();
            }

            private string FindElement()
            {
                if (new Random().Next(0, 5) == 3)
                    return "Http element returned";

                if (this.handler != null)
                    return this.handler.Find();

                return null;
            }
        }

        public class DbOrderHandler : OrderHandlerBase
        {
            public override string Find()
            {
                return FindElement();
            }

            private string FindElement()
            {
                if (new Random().Next(3, 4) == 3)
                    return "Db element returned";

                if (this.handler != null)
                    return this.handler.Find();

                return null;
            }
        }

        #endregion
    }
}
