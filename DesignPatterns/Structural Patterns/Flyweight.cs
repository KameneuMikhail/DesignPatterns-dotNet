using System.Collections.Generic;

namespace DesignPatterns.Structural_Patterns
{
    /// <summary>
    /*
     На досуге вы решили написать небольшую игру, в которой игроки перемещаются по карте и стреляют друг в друга.
    Фишкой игры должна была стать реалистичная система частиц. Пули, снаряды, осколки от взрывов — всё это должно красиво летать и радовать взгляд.

    Игра отлично работала на вашем мощном компьютере.
    Однако ваш друг сообщил, что игра начинает тормозить и вылетает через несколько минут после запуска.
    Покопавшись в логах, вы обнаружили, что игра вылетает из-за недостатка оперативной памяти.
    У вашего друга компьютер значительно менее «прокачанный», поэтому проблема у него и проявляется так быстро.

    И действительно, каждая частица представлена собственным объектом, имеющим множество данных.
    В определённый момент, когда побоище на экране достигает кульминации, новые объекты частиц уже не вмещаются в оперативную память компьютера, и программа вылетает.

    Если внимательно посмотреть на класс частиц, то можно заметить, что цвет и спрайт занимают больше всего памяти.
    Более того, они хранятся в каждом объекте, хотя фактически их значения одинаковы для большинства частиц.

    Остальное состояние объектов — координаты, вектор движения и скорость — отличаются для всех частиц.
    Таким образом, эти поля можно рассматривать как контекст, в котором частица используется. А цвет и спрайт — это данные, не изменяющиеся во времени.

    Неизменяемые данные объекта принято называть «внутренним состоянием». Все остальные данные — это «внешнее состояние».

    Паттерн Легковес предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.
    Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах.
    Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием, а оно имеет не так много вариаций.

    В нашем примере решением было бы создать дополнительный класс-контекст, который бы связывал внешнее состояние с тем или иным легковесом.
    Это позволит обойтись только одним полем-массивом в классе контейнера.

    «Но погодите-ка, нам потребуется столько же этих объектов, сколько было в самом начале!», — скажете вы и будете правы!
    Но дело в том, что объекты-контексты занимают намного меньше места, чем первоначальные.
    Ведь самые тяжёлые поля остались в легковесах (простите за каламбур), и сейчас мы будем ссылаться на эти объекты из контекстов, вместо того, чтобы повторно хранить дублирующееся состояние.

    Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние невозможно изменить после создания.
    Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

    Для удобства работы с легковесами и контекстами можно создать фабричный метод, принимающий в параметрах всё внутреннее (а иногда и внешнее) состояние желаемого объекта.

    Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием, что и требуемое.
    Если легковес находится, его можно повторно использовать. Если нет — просто создаём новый.
    Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.
     */
    /// </summary>
    public class Flyweight
    {
        #region Weapons

        public enum WeaponType: byte
        {
            Gun,
            Knife
        }

        public class Position
        {
            public int X { get; set; }
            public int Y { get; set; }
        }

        public class View
        {
            public string Image { get; }
            public View(string image)
            {
                Image = image;
            }
        }

        public class Weapon
        {
            private FlyweightFactory factory;
            public WeaponType Name { get; set; }
            public Position Position { get; set; }
            public View View { get; }

            public Weapon(WeaponType name)
            {
                factory = new FlyweightFactory();
                Position = new Position();
                View = factory.GetView(name);
            }
        }
        #endregion

        #region Flyweight

        public class FlyweightFactory
        {
            private IDictionary<WeaponType, View> views;

            public FlyweightFactory()
            {
                views = new Dictionary<WeaponType, View>();
            }

            public View GetView(WeaponType name)
            {
                View view;
                views.TryGetValue(name, out view);
                if (view != null)
                    return view;

                // Can be rewrite with Factory Method pattern
                switch (name)
                {
                    case WeaponType.Gun:
                        {
                            var v = new View("Gun");
                            views.Add(WeaponType.Gun, v);
                            return v;
                        }
                    case WeaponType.Knife:
                        {
                            var v = new View("Knife");
                            views.Add(WeaponType.Knife, v);
                            return v;
                        }
                }

                return null;
            }
        }

        #endregion
    }
}
